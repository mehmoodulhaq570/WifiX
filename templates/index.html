<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>WifiX — Upload</title>
    <style>
      :root {
        --bg: #f3f4f6;
        --card: #ffffff;
        --accent: #6366f1;
        --muted: #6b7280;
        --text: #111827;
        --muted-2: #9ca3af;
      }
      .dark {
        --bg: #0b1220;
        --card: #071027;
        --accent: #7c3aed;
        --muted: #9ca3af;
        --text: #e6eef8;
        --muted-2: #9aa6b2;
      }
      html,
      body {
        height: 100%;
        margin: 0;
        font-family: Inter, Segoe UI, Roboto, Arial, sans-serif;
        background: var(--bg);
        color: var(--text);
      }
      .container {
        max-width: 1200px;
        width: calc(100% - 48px);
        margin: 24px auto;
        padding: 24px;
      }
      .card {
        background: var(--card);
        border-radius: 12px;
        box-shadow: 0 6px 18px rgba(15, 23, 42, 0.08);
        padding: 28px;
      }
      h1 {
        margin: 0 0 8px;
        font-size: 1.5rem;
      }
      p.lead {
        margin: 0 0 16px;
        color: var(--muted);
      }
      .uploader {
        border-width: 3px;
        border-style: dotted;
        border-color: rgba(99, 102, 241, 0.6);
        border-radius: 12px;
        padding: 28px;
        text-align: center;
        cursor: pointer;
        transition: all 0.15s ease-in-out;
        background: linear-gradient(
          180deg,
          rgba(255, 255, 255, 0.6),
          transparent
        );
      }
      .uploader.drag {
        background: linear-gradient(
          90deg,
          rgba(99, 102, 241, 0.06),
          rgba(99, 102, 241, 0.02)
        );
        border-color: rgba(99, 102, 241, 0.85);
        box-shadow: 0 10px 30px rgba(99, 102, 241, 0.12);
      }
      .uploader input[type="file"] {
        display: none;
      }
      .btn {
        display: inline-flex;
        align-items: center;
        gap: 8px;
        padding: 10px 14px;
        border-radius: 8px;
        border: none;
        cursor: pointer;
      }
      .btn.primary {
        background: linear-gradient(90deg, var(--accent), #8b5cf6);
        color: white;
        box-shadow: 0 6px 14px rgba(99, 102, 241, 0.18);
      }
      .btn.ghost {
        background: transparent;
        border: 1px solid #e6e8f0;
        color: #111827;
      }
      .row {
        display: flex;
        gap: 12px;
        flex-wrap: wrap;
        margin-top: 16px;
      }

      /* Layout: main + sidebar */
      .layout {
        display: grid;
        grid-template-columns: 1fr;
        gap: 20px;
        align-items: start;
      }
      /* layout children styling handled via main/aside selectors and media queries */
      .sidebar {
        background: transparent;
      }
      #files-list {
        padding-right: 6px;
      }
      .progress {
        height: 10px;
        background: #eef2ff;
        border-radius: 999px;
        overflow: hidden;
      }
      .progress > i {
        display: block;
        height: 100%;
        width: 0;
        background: linear-gradient(90deg, #60a5fa, #8b5cf6);
      }
      .meta {
        margin-top: 14px;
        color: var(--muted);
        font-size: 0.9rem;
      }
      .qr {
        margin-top: 12px;
      }
      a.link {
        color: var(--accent);
        text-decoration: none;
      }
      footer {
        margin-top: 18px;
        color: var(--muted);
        font-size: 0.85rem;
      }
      @media (max-width: 900px) {
        .container {
          margin: 18px 12px;
          padding: 18px;
        }
      }

      @media (min-width: 900px) {
        .layout {
          grid-template-columns: 1.4fr 0.8fr;
        }
        .uploader {
          min-height: 260px;
          display: flex;
          align-items: center;
          justify-content: center;
        }
        #files-list {
          max-height: 60vh;
          overflow: auto;
        }
      }
      /* file-row responsive tweaks */
      .file-row {
        grid-template-columns: 1fr auto;
      }
      @media (min-width: 900px) {
        .file-row {
          grid-template-columns: 2fr 80px 120px 80px 100px;
        }
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="card">
        <div
          style="
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
          "
        >
          <div style="flex: 1; text-align: center">
            <h1 style="margin: 0">WifiX — Share files on your LAN</h1>
            <p class="lead" style="margin-top: 6px">
              Quickly upload files from any device and share a temporary
              download link.
            </p>
          </div>
          <div style="flex: 0 0 auto; text-align: right">
            <button id="theme-toggle" class="btn ghost" title="Toggle theme">
              🌙
            </button>
          </div>
        </div>

        <!-- Responsive two-column layout: uploader/main and sidebar -->
        <div class="layout">
          <main>
            <label class="uploader" id="dropzone">
              <input
                id="file-input"
                type="file"
                name="file"
                aria-label="Choose file to upload"
              />
              <div>
                <strong id="dz-text"
                  >Click or drop a file here to upload</strong
                >
                <div class="meta">
                  Supported: any file (configurable). Max: server limit.
                </div>
              </div>
            </label>
            <div id="selected-name" class="meta" style="margin-top: 8px">
              No file selected
            </div>

            <div class="row" style="margin-top: 12px">
              <button id="upload-btn" class="btn primary">Upload</button>
              <button id="show-server-qr" class="btn ghost">
                Show Server QR
              </button>
              <button id="start-server-btn" class="btn ghost">
                Start server (Become host)
              </button>
              <button id="connect-host-btn" class="btn" style="display: none">
                Connect to host
              </button>
              <a
                id="download-link"
                class="btn"
                style="display: none"
                target="_blank"
                >Open</a
              >
            </div>

            <div class="meta" id="status" style="margin-top: 12px">
              No uploads yet.
            </div>

            <div style="margin-top: 12px; display: none" id="progress-wrap">
              <div class="progress"><i id="progress-bar"></i></div>
              <div class="meta" id="progress-text">0%</div>
            </div>

            <div
              class="qr"
              id="qr-area"
              style="display: none; margin-top: 12px"
            >
              <img
                id="qr-img"
                alt="QR code"
                style="
                  max-width: 100%;
                  width: 240px;
                  border-radius: 8px;
                  border: 1px solid #eef2ff;
                  display: block;
                  margin: auto;
                "
              />
            </div>
          </main>

          <aside class="sidebar">
            <div id="server-info" class="meta" style="margin-bottom: 12px">
              <strong>Server addresses:</strong>
              <div id="server-urls" style="margin-top: 8px"></div>
            </div>

            <div id="shared-files" style="margin-top: 8px">
              <strong>Available files</strong>
              <div
                id="files-list"
                class="meta"
                style="margin-top: 8px; max-height: 60vh; overflow: auto"
              >
                Loading…
              </div>
            </div>
          </aside>
        </div>

        <footer>
          Tip: Scan the QR to open the link on a phone. Use the server QR to
          connect other devices to this host.
        </footer>
      </div>
    </div>

    <script>
      // Socket.IO client (load via CDN)
      (function () {
        const s = document.createElement("script");
        s.src = "https://cdn.socket.io/4.7.2/socket.io.min.js";
        s.defer = true;
        document.head.appendChild(s);
      })();

      // PIN modal (hidden by default)
      const pinModalHtml = `
        <div id="pin-modal" style="position:fixed;left:0;top:0;right:0;bottom:0;background:rgba(0,0,0,0.5);display:flex;align-items:center;justify-content:center;z-index:9999;">
          <div style="background:white;padding:20px;border-radius:8px;max-width:420px;width:90%;box-shadow:0 6px 20px rgba(0,0,0,0.2);">
            <h3 style="margin-top:0">Enter access PIN</h3>
            <p class="meta">This server requires a PIN to join. Ask the host for the PIN.</p>
            <input id="pin-input" type="password" aria-label="PIN" placeholder="PIN" style="width:100%;padding:8px;margin-top:8px;border-radius:6px;border:1px solid #e6e8f0" />
            <div style="display:flex;gap:8px;margin-top:12px;justify-content:flex-end;">
              <button id="pin-submit" class="btn primary">Enter</button>
            </div>
            <div id="pin-error" style="color:#BE123C;margin-top:8px;display:none"></div>
          </div>
        </div>`;

      const dropzone = document.getElementById("dropzone");
      const input = document.getElementById("file-input");
      const uploadBtn = document.getElementById("upload-btn");
      const status = document.getElementById("status");
      const progressWrap = document.getElementById("progress-wrap");
      const progressBar = document.getElementById("progress-bar");
      const progressText = document.getElementById("progress-text");
      const downloadLink = document.getElementById("download-link");
      const qrImg = document.getElementById("qr-img");
      const qrArea = document.getElementById("qr-area");
      const showServerQr = document.getElementById("show-server-qr");
      const selectedName = document.getElementById("selected-name");
      const serverUrls = document.getElementById("server-urls");

      // fetch server connection info (host_url and lan_url)
      fetch("/info")
        .then((r) => r.json())
        .then((info) => {
          serverUrls.innerHTML = "";
          const makeRow = (label, url) => {
            const row = document.createElement("div");
            row.style.display = "flex";
            row.style.gap = "8px";
            row.style.alignItems = "center";
            const a = document.createElement("a");
            a.href = url;
            a.textContent = url;
            a.className = "link";
            a.target = "_blank";
            const copyBtn = document.createElement("button");
            copyBtn.textContent = "Copy";
            copyBtn.className = "btn";
            copyBtn.style.padding = "6px 8px";
            copyBtn.addEventListener("click", () =>
              navigator.clipboard.writeText(url)
            );
            const qrBtn = document.createElement("button");
            qrBtn.textContent = "QR";
            qrBtn.className = "btn ghost";
            qrBtn.style.padding = "6px 8px";
            qrBtn.addEventListener("click", () => {
              qrImg.src = "/qr?url=" + encodeURIComponent(url);
              qrArea.style.display = "block";
            });
            const lbl = document.createElement("div");
            lbl.style.minWidth = "90px";
            lbl.textContent = label + ":";
            row.appendChild(lbl);
            row.appendChild(a);
            row.appendChild(copyBtn);
            row.appendChild(qrBtn);
            return row;
          };
          // Show a single shareable address to avoid duplicate QR buttons.
          // Prefer the LAN URL when it appears to be a non-loopback address,
          // otherwise fall back to the host_url.
          const isLoopback =
            info.lan_ip === "127.0.0.1" ||
            info.lan_ip === undefined ||
            info.lan_ip === null;
          const shareUrl =
            !isLoopback && info.lan_url ? info.lan_url : info.host_url;
          serverUrls.appendChild(makeRow("Shareable", shareUrl));
        })
        .catch(() => {
          serverUrls.textContent = "Unable to fetch server info.";
        });

      // keep selected file reference (drag-drop can't reliably set input.files)
      let selectedFile = null;
      // whether this client has been approved by the host
      let isApproved = false;

      function setSelected(file) {
        selectedFile = file || null;
        if (selectedFile) {
          selectedName.textContent =
            selectedFile.name +
            " (" +
            Math.round(selectedFile.size / 1024) +
            " KB)";
        } else {
          selectedName.textContent = "No file selected";
        }
      }

      // Drag & drop UI
      ["dragenter", "dragover"].forEach((e) => {
        dropzone.addEventListener(e, (ev) => {
          ev.preventDefault();
          ev.stopPropagation();
          dropzone.classList.add("drag");
          document.getElementById("dz-text").textContent =
            "Drop file to upload";
        });
      });
      ["dragleave", "drop"].forEach((e) => {
        dropzone.addEventListener(e, (ev) => {
          ev.preventDefault();
          ev.stopPropagation();
          dropzone.classList.remove("drag");
          document.getElementById("dz-text").textContent =
            "Click or drop a file here to upload";
        });
      });
      dropzone.addEventListener("drop", (ev) => {
        const f =
          ev.dataTransfer && ev.dataTransfer.files && ev.dataTransfer.files[0];
        if (f) {
          // store selected file (can't reliably programmatically set input.files)
          setSelected(f);
        }
      });
      // label already triggers the file input on click; avoid calling input.click()
      // to prevent the file picker appearing twice. Add keyboard support instead.
      dropzone.setAttribute("tabindex", "0");
      // optimistically add to files list with size/type
      try {
        const wrap = document.getElementById("files-list");
        if (wrap) {
          const node = renderFileItem({
            filename: json.filename || file.name,
            url: url,
            mtime: Date.now() / 1000,
            size: file.size,
            type: file.name.split(".").pop(),
          });
          if (wrap.querySelector("div")) {
            // if header exists, append after header
            const first = wrap.querySelector("div");
            if (first) wrap.insertBefore(node, first.nextSibling);
            else wrap.appendChild(node);
          } else {
            wrap.appendChild(node);
          }
        }
      } catch (e) {
        console.warn("append optimistic", e);
      }
      dropzone.addEventListener("keydown", (ev) => {
        if (ev.key === "Enter" || ev.key === " ") {
          ev.preventDefault();
          input.click();
        }
      });

      // when user picks file via native picker
      input.addEventListener("change", (ev) => {
        const f = input.files && input.files[0];
        setSelected(f);
      });

      uploadBtn.addEventListener("click", () => {
        const file = selectedFile || (input.files && input.files[0]);
        if (!file) {
          status.textContent = "Please select a file first.";
          return;
        }
        status.textContent = `Uploading ${file.name}...`;
        progressWrap.style.display = "block";
        progressBar.style.width = "0%";
        progressText.textContent = "0%";
        uploadBtn.disabled = true;

        const xhr = new XMLHttpRequest();
        xhr.open("POST", "/upload", true);
        xhr.upload.onprogress = function (e) {
          if (e.lengthComputable) {
            const pct = Math.round((e.loaded / e.total) * 100);
            progressBar.style.width = pct + "%";
            progressText.textContent = pct + "%";
          }
        };
        xhr.onload = function () {
          progressBar.style.width = "100%";
          progressText.textContent = "Done";
          if (xhr.status >= 200 && xhr.status < 300) {
            try {
              const json = JSON.parse(xhr.responseText);
              const url = json.url || json.data?.url || null;
              if (url) {
                status.innerHTML = `Uploaded: <a class=\"link\" href=\"${url}\" target=\"_blank\">${url}</a>`;
                downloadLink.href = url;
                downloadLink.style.display = "inline-flex";
                downloadLink.textContent = "Open Download";
                // show QR for the download link
                qrImg.src = "/qr?url=" + encodeURIComponent(url);
                qrArea.style.display = "block";
              } else {
                status.textContent = "Upload succeeded but no URL returned.";
              }
            } catch (err) {
              status.textContent =
                "Upload completed but failed to parse server response.";
            }
          } else {
            status.textContent = "Upload failed: " + xhr.statusText;
          }
        };
        xhr.onerror = function () {
          status.textContent = "Upload error.";
        };
        xhr.onloadend = function () {
          uploadBtn.disabled = false;
        };
        const fd = new FormData();
        fd.append("file", file);
        xhr.send(fd);
      });

      showServerQr.addEventListener("click", () => {
        qrImg.src = "/qr";
        qrArea.style.display = "block";
        status.textContent = "Server QR shown below.";
      });

      // --- Shared files + realtime updates via Socket.IO ---
      function renderFileItem(item) {
        // row container
        const row = document.createElement("div");
        row.className = "file-row";
        row.dataset.filename = item.filename;
        row.style.display = "grid";
        row.style.gridTemplateColumns = "2fr 80px 120px 80px 100px";
        row.style.alignItems = "center";
        row.style.gap = "8px";
        row.style.padding = "8px 6px";
        row.style.borderBottom = "1px solid rgba(0,0,0,0.04)";

        // filename (clickable)
        const nameWrap = document.createElement("div");
        const a = document.createElement("a");
        a.href = item.url;
        a.textContent = item.filename;
        a.target = "_blank";
        a.className = "link";
        a.style.fontWeight = "600";
        a.style.display = "inline-block";
        a.style.maxWidth = "100%";
        a.style.overflow = "hidden";
        a.style.textOverflow = "ellipsis";
        a.style.whiteSpace = "nowrap";
        nameWrap.appendChild(a);

        // size
        const sizeCol = document.createElement("div");
        sizeCol.textContent = item.size
          ? Math.round(item.size / 1024) + " KB"
          : "";
        sizeCol.style.fontSize = "0.9rem";
        sizeCol.style.color = "var(--muted)";

        // modified
        const when = document.createElement("div");
        when.style.fontSize = "0.85rem";
        when.style.color = "var(--muted)";
        try {
          when.textContent = new Date(
            (item.mtime || Date.now()) * 1000
          ).toLocaleString();
        } catch (e) {
          when.textContent = "";
        }

        // type
        const typeCol = document.createElement("div");
        typeCol.textContent = item.type || item.filename.split(".").pop() || "";
        typeCol.style.fontSize = "0.9rem";
        typeCol.style.color = "var(--muted)";

        // actions
        const actions = document.createElement("div");
        actions.style.display = "flex";
        actions.style.gap = "8px";
        // download icon button
        const dl = document.createElement("a");
        dl.href = item.url;
        dl.target = "_blank";
        dl.className = "btn";
        dl.title = "Download";
        dl.innerHTML = "\u2B07"; // down arrow
        dl.style.padding = "6px 8px";
        // trash button
        const del = document.createElement("button");
        del.className = "btn ghost";
        del.title = "Delete";
        del.style.padding = "6px 8px";
        del.textContent = "🗑";
        del.addEventListener("click", () => confirmDelete(item.filename, row));

        // copy link button
        const copy = document.createElement("button");
        copy.className = "btn";
        copy.textContent = "Copy";
        copy.style.padding = "6px 8px";
        copy.addEventListener("click", () =>
          navigator.clipboard.writeText(item.url)
        );

        actions.appendChild(dl);
        actions.appendChild(copy);
        actions.appendChild(del);

        row.appendChild(nameWrap);
        row.appendChild(sizeCol);
        row.appendChild(when);
        row.appendChild(typeCol);
        row.appendChild(actions);
        return row;
      }

      function loadFiles() {
        fetch("/files")
          .then((r) => r.json())
          .then((items) => {
            const wrap = document.getElementById("files-list");
            wrap.innerHTML = "";
            if (!items || items.length === 0) {
              wrap.textContent = "No files yet.";
              return;
            }
            // header row
            const header = document.createElement("div");
            header.style.display = "grid";
            header.style.gridTemplateColumns = "2fr 80px 120px 80px 100px";
            header.style.fontWeight = "700";
            header.style.padding = "6px 4px";
            header.style.borderBottom = "2px solid rgba(0,0,0,0.06)";
            ["Filename", "Size", "Modified", "Type", "Actions"].forEach((h) => {
              const d = document.createElement("div");
              d.textContent = h;
              header.appendChild(d);
            });
            wrap.appendChild(header);
            items.forEach((it) => wrap.appendChild(renderFileItem(it)));
          })
          .catch(() => {
            document.getElementById("files-list").textContent =
              "Failed to load files.";
          });
      }

      // Single shared socket instance and auto-request behavior
      window.sock = null;
      window.becameHost = false;
      window._autoRequested = false;

      function initSocket() {
        if (typeof io === "undefined") {
          setTimeout(initSocket, 200);
          return;
        }
        try {
          if (!window.sock) window.sock = io();
          const socket = window.sock;

          socket.on("connect", () => {
            console.debug("socket connected", socket.id);
            // If this client is not acting as host, auto-request connection when opening the host IP
            if (!window.becameHost && !window._autoRequested) {
              try {
                socket.emit("request_connect", { name: null });
                window._autoRequested = true;
                status.textContent = "Requesting connection to host...";
              } catch (e) {
                console.warn("auto request failed", e);
              }
            }
          });

          socket.on("file_uploaded", (data) => {
            // Only insert newly uploaded files into the UI when this client
            // has been approved by the host or is the host itself. This is a
            // UI-level safety net to avoid showing files to unapproved users.
            if (!window.becameHost && !isApproved) return;
            const wrap = document.getElementById("files-list");
            if (wrap && typeof data.url !== "undefined") {
              // avoid duplicate rows if already present
              if (wrap.querySelector(`[data-filename="${data.filename}"]`))
                return;
              const node = renderFileItem({
                filename: data.filename,
                url: data.url,
                mtime: Date.now() / 1000,
                size: data.size || 0,
                type: data.type || "",
              });
              if (wrap.firstChild) wrap.insertBefore(node, wrap.firstChild);
              else wrap.appendChild(node);
            }
          });

          // file_deleted: remove file row from list when server deletes it
          socket.on("file_deleted", (d) => {
            try {
              const fn = d && d.filename;
              if (!fn) return;
              const wrap = document.getElementById("files-list");
              if (!wrap) return;
              const el = wrap.querySelector(`[data-filename="${fn}"]`);
              if (el) el.remove();
            } catch (e) {
              console.warn("remove file failed", e);
            }
          });

          // Requests approved/denied for this client
          socket.on("request_approved", (d) => {
            // mark this client as approved and load files now
            isApproved = true;
            status.textContent = "Connected to host.";
            try {
              loadFiles();
            } catch (e) {
              console.warn("loadFiles after approval failed", e);
            }
          });
          socket.on("request_denied", (d) => {
            status.textContent = "Connection denied by host.";
          });
          socket.on("host_status", (st) => {
            if (st && st.available === false) {
              status.textContent = "Host is not available.";
            }
          });

          // incoming_request may be received by any socket but we only show it when we're the host
          socket.on("incoming_request", (data) => {
            if (!window.becameHost) return; // ignore unless host
            const name = data.name || "Guest";
            const sid = data.sid;
            const box = document.createElement("div");
            box.style.position = "fixed";
            box.style.right = "18px";
            box.style.top = "18px";
            box.style.background = "white";
            box.style.padding = "12px";
            box.style.borderRadius = "8px";
            box.style.boxShadow = "0 6px 18px rgba(0,0,0,0.12)";
            box.style.zIndex = 9999;
            box.innerHTML = `<div><strong>Connection request</strong></div><div style='margin-top:8px'>${name} wants to connect.</div>`;
            const allow = document.createElement("button");
            allow.className = "btn primary";
            allow.textContent = "Allow";
            allow.style.marginLeft = "8px";
            const deny = document.createElement("button");
            deny.className = "btn ghost";
            deny.textContent = "Deny";
            deny.style.marginLeft = "8px";
            const controls = document.createElement("div");
            controls.style.marginTop = "8px";
            controls.appendChild(allow);
            controls.appendChild(deny);
            box.appendChild(controls);
            document.body.appendChild(box);
            allow.addEventListener("click", () => {
              socket.emit("approve_request", { sid });
              box.remove();
              status.textContent = `${name} approved.`;
            });
            deny.addEventListener("click", () => {
              socket.emit("deny_request", { sid });
              box.remove();
              status.textContent = `${name} denied.`;
            });
          });
        } catch (e) {
          console.warn("socket init failed", e);
        }
      }

      // PIN flow: check status and show modal if required
      function ensureAuthThenInit() {
        // We initialize auth first, but do NOT load files until the host approves
        // the requesting client. This ensures files are only visible after
        // host approval (UI-level enforcement).
        fetch("/auth/status")
          .then((r) => r.json())
          .then((st) => {
            if (st.pin_required && !st.authed) {
              // show modal
              const div = document.createElement("div");
              div.innerHTML = pinModalHtml;
              document.body.appendChild(div);
              const submit = document.getElementById("pin-submit");
              const pinInput = document.getElementById("pin-input");
              const pinErr = document.getElementById("pin-error");
              submit.addEventListener("click", () => {
                const pin = pinInput.value || "";
                fetch("/auth", {
                  method: "POST",
                  headers: { "Content-Type": "application/json" },
                  body: JSON.stringify({ pin }),
                })
                  .then((r) => {
                    if (r.ok) return r.json();
                    throw r;
                  })
                  .then((j) => {
                    if (j.authed) {
                      div.remove();
                      // don't load files yet; wait for host approval
                      initSocket();
                    }
                  })
                  .catch(() => {
                    pinErr.style.display = "block";
                    pinErr.textContent = "Invalid PIN";
                  });
              });
            } else {
              // do not call loadFiles() here — only load after approval
              initSocket();
            }
          })
          .catch(() => {
            initSocket();
          });
      }

      ensureAuthThenInit();

      // Delete confirmation and action
      function confirmDelete(filename, rowEl) {
        const modal = document.createElement("div");
        modal.style.position = "fixed";
        modal.style.left = 0;
        modal.style.top = 0;
        modal.style.right = 0;
        modal.style.bottom = 0;
        modal.style.background = "rgba(0,0,0,0.45)";
        modal.style.display = "flex";
        modal.style.alignItems = "center";
        modal.style.justifyContent = "center";
        modal.style.zIndex = 9999;
        modal.innerHTML = `<div style="background:white;padding:18px;border-radius:8px;max-width:420px;width:90%"><h3 style="margin:0 0 8px">Delete file?</h3><div class="meta" style="margin-bottom:12px">Are you sure you want to permanently delete <strong>${filename}</strong>?</div><div style="display:flex;justify-content:flex-end;gap:8px"><button id="del-cancel" class="btn ghost">Cancel</button><button id="del-confirm" class="btn primary">Delete</button></div></div>`;
        document.body.appendChild(modal);
        document
          .getElementById("del-cancel")
          .addEventListener("click", () => modal.remove());
        document.getElementById("del-confirm").addEventListener("click", () => {
          // call DELETE endpoint
          fetch("/delete/" + encodeURIComponent(filename), { method: "DELETE" })
            .then((r) => {
              if (r.ok) return r.json();
              throw r;
            })
            .then(() => {
              // remove row from UI
              if (rowEl && rowEl.remove) rowEl.remove();
              status.textContent = "File deleted";
              modal.remove();
            })
            .catch(async (err) => {
              let msg = "Delete failed";
              try {
                const j = await err.json();
                if (j && j.error) msg = j.error;
              } catch (e) {}
              status.textContent = msg;
              modal.remove();
            });
        });
      }

      // --- Host / Connect UI wiring ---
      function attachHostUi() {
        const startBtn = document.getElementById("start-server-btn");
        const connectBtn = document.getElementById("connect-host-btn");
        // show connect button for clients by default
        connectBtn.style.display = "inline-flex";

        startBtn.addEventListener("click", () => {
          // become the host: inform server
          if (typeof io === "undefined") {
            setTimeout(() => startBtn.click(), 200);
            return;
          }
          // reuse shared socket
          const s = window.sock || io();
          window.sock = s;
          window.becameHost = true;
          s.emit("become_host", {});
          startBtn.textContent = "Host: waiting for requests...";
          startBtn.disabled = true;
          // show LAN URL for users to enter
          fetch("/info")
            .then((r) => r.json())
            .then((info) => {
              status.innerHTML = `Share this IP to allow connections: <strong>${info.lan_ip}</strong>`;
              connectBtn.style.display = "none";
            })
            .catch(() => {});

          // incoming_request handling is installed by initSocket and will execute only when window.becameHost is true
        });

        connectBtn.addEventListener("click", () => {
          // request connect to host (uses shared socket)
          if (typeof io === "undefined") {
            setTimeout(() => connectBtn.click(), 200);
            return;
          }
          // prevent duplicate requests: if an auto-request already fired, don't send again
          if (window._autoRequested) {
            status.textContent =
              "Connection request already sent. Waiting for host approval...";
            connectBtn.disabled = true;
            return;
          }
          const sock = window.sock || io();
          window.sock = sock;
          const displayName =
            prompt("Name to show to host (optional)") || "Guest";
          try {
            sock.emit("request_connect", { name: displayName });
            window._autoRequested = true; // mark that a request was sent to avoid duplicates
          } catch (e) {
            console.warn("emit request_connect failed", e);
          }
          status.textContent =
            "Connection request sent. Waiting for host approval...";
          connectBtn.disabled = true;

          // handlers are installed in initSocket; ensure socket is initialized
          initSocket();
        });
      }

      // Attach host UI after init (this will reveal the buttons and wire handlers)
      // Delay slightly to ensure socket.io script has a chance to load
      setTimeout(() => {
        try {
          attachHostUi();
        } catch (e) {
          console.warn("attachHostUi failed", e);
        }
      }, 300);

      // Theme toggle (day/night) persisted in localStorage
      const themeToggle = document.getElementById("theme-toggle");
      function applyTheme(t) {
        if (t === "dark") document.documentElement.classList.add("dark");
        else document.documentElement.classList.remove("dark");
        if (themeToggle) themeToggle.textContent = t === "dark" ? "☀️" : "🌙";
      }
      // initialize from storage or prefers-color-scheme
      let theme = localStorage.getItem("wifix_theme");
      if (!theme) {
        theme =
          window.matchMedia &&
          window.matchMedia("(prefers-color-scheme: dark)").matches
            ? "dark"
            : "light";
      }
      applyTheme(theme);
      if (themeToggle)
        themeToggle.addEventListener("click", () => {
          theme = document.documentElement.classList.contains("dark")
            ? "light"
            : "dark";
          applyTheme(theme);
          localStorage.setItem("wifix_theme", theme);
        });
    </script>
  </body>
</html>
